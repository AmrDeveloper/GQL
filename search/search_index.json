{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"GQL - Git Query Language <p>GQL is a query language with a syntax very similar to SQL with a tiny engine to perform queries on .git files instance of database files, the engine executes the query on the fly without the need to create database files or convert .git files into any other format, note that all Keywords in GQL are case-insensitive similar to SQL.</p>"},{"location":"#samples","title":"Samples","text":"<pre><code>SELECT 1\nSELECT 1 + 2\nSELECT LEN(\"Git Query Language\")\nSELECT \"One\" IN (\"One\", \"Two\", \"Three\")\nSELECT \"Git Query Language\" LIKE \"%Query%\"\nSELECT INTERVAL '1 year 2 mons 3 days 04:05:06.789'\n\nSET @arr = [1, 2, 3];\nSELECT [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\nSELECT @arr[1], @arr[2], @arr[3], ARRAY_LENGTH(@arr);\nSELECT @arr[1:2], @arr[2:], @arr[:2];\n\nSELECT DISTINCT title AS tt FROM commits\nSELECT author_name, COUNT(author_name) AS commit_num FROM commits GROUP BY author_name, author_email ORDER BY commit_num DESC LIMIT 10\nSELECT commit_count FROM branches WHERE commit_count BETWEEN 0 AND 10\n\nSELECT * FROM refs WHERE type = \"branch\"\nSELECT * FROM refs ORDER BY type\n\nSELECT * FROM commits\nSELECT author_name, author_email FROM commits\nSELECT author_name, author_email FROM commits ORDER BY author_name DESC, author_email ASC\nSELECT author_name, author_email FROM commits WHERE author_email LIKE \"%gmail%\" ORDER BY author_name\nSELECT * FROM commits WHERE LOWER(author_name) = \"amrdeveloper\"\nSELECT author_name FROM commits GROUP By author_name\nSELECT author_name FROM commits GROUP By author_name HAVING author_name = \"AmrDeveloper\"\n\nSELECT * FROM branches\nSELECT * FROM branches WHERE is_head = true\nSELECT name, LEN(name) FROM branches\n\nSELECT * FROM tags\nSELECT * FROM tags OFFSET 1 LIMIT 1\n\nSELECT path, count() AS changes_count, SUM(insertions) AS additions, SUM(removals) AS removes FROM diffs_changes GROUP BY path ORDER BY changes_count DESC\n</code></pre>"},{"location":"#gitql-documentation","title":"GitQL Documentation","text":"<ul> <li>Full Documentation</li> <li>Install or Build</li> <li>Tables</li> <li>Types</li> <li>Statements</li> <li>Expressions</li> <li>Functions and Operators</li> <li>Aggregations</li> </ul>"},{"location":"#gitql-sdk-documentations","title":"GitQL SDK Documentations","text":"<ul> <li>GitQL SDK</li> <li>Customize the Data Schema.</li> <li>Customize the Data Provider.</li> <li>Customize the Standard library.</li> <li>Customize the Type system.</li> <li>Customize the Value system.</li> <li>Connect Components together.</li> </ul>"},{"location":"gitql_functions/","title":"GitQL Functions","text":""},{"location":"gitql_functions/#gitql-application-functions","title":"GitQL Application Functions","text":"<p>Beside the common SQL scalar, aggregation and window functions there are some extra functions related to the GitQL as application not as SDK, those functions are available only in the gitql application.</p>"},{"location":"gitql_functions/#gitql-commits-functions","title":"GitQL Commits functions","text":"Name Parameters Return Description COMMIT_CONVENTIONAL Text Text Return the commit conventional from commits (Part before the <code>:</code>)."},{"location":"gitql_functions/#gitql-diffs-functions","title":"GitQL Diffs functions","text":"Name Parameters Return Description DIFF_CONTENT DiffChanges Text Return the full content of all changes appended together. DIFF_ADDED_CONTENT DiffChanges Text Return the added content of all changes appended together. DIFF_DELETED_CONTENT DiffChanges Text Return the deleted content of all changes appended together. DIFF_MODIFIED_CONTENT DiffChanges Text Return the modified content of all changes appended together. DIFF_CONTENT_CONTAINS DiffChanges, Text Text Return true if the all content of changes contains second argument. DIFF_ADDED_CONTENT_CONTAINS DiffChanges, Text Text Return true if the added content of changes contains second argument. DIFF_DELETED_CONTENT_CONTAINS DiffChanges, Text Text Return true if the deleted content of changes contains second argument. DIFF_MODIFICATION_CONTENT_CONTAINS DiffChanges, Text Text Return true if the modified content of changes contains second argument. DIFF_CHANGED_FILES DiffChanges Array Return changes files in this change as array of strings. DIFF_FILES_COUNT DiffChanges Integer Return number of unique files changes in this commit. IS_DIFF_HAS_FILE DiffChanges, Text Boolean Return true if this diff changes contains file."},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#install-from-package-managers","title":"Install from Package managers","text":""},{"location":"setup/#cargoio","title":"Cargo.io","text":"<pre><code>cargo install gitql\n</code></pre> <p>Note that from version <code>0.10.0</code> onward installing from Cargo requires <code>Cmake</code> to be installed so it can build the dependencies.</p>"},{"location":"setup/#winget-on-windows","title":"Winget on Windows","text":"<pre><code>winget install gitql\n</code></pre>"},{"location":"setup/#scoop-on-windows","title":"Scoop on Windows","text":"<pre><code>scoop install gitql\n</code></pre>"},{"location":"setup/#homebrew-on-macos-and-linux","title":"Homebrew on MacOS and Linux","text":"<pre><code>brew install gql\n</code></pre>"},{"location":"setup/#on-single-repository","title":"On Single repository","text":"<p>gitql"},{"location":"setup/#on-multi-repositories","title":"On multi repositories","text":"<p>gitql --repo   ...etc"},{"location":"setup/#or","title":"Or","text":"<p>gitql -r   ...etc <pre><code>## Download Binaries\n\nFrom Github repository page you can download the right executable for your OS and Arch from the latest release\n\n## Build GQL From source code\n\n```sh\ngit clone https://github.com/amrdeveloper/gql\ncd gql\n\n# On Single repository\ncargo run &lt;repository_path&gt;\n\n# On multi repositories\ncargo run -- --repo &lt;repository_path&gt; &lt;repository_path&gt; ...etc\ncargo run -- -r &lt;repository_path&gt; &lt;repository_path&gt; ...etc\n</code></pre>"},{"location":"setup/#command-line-arguments","title":"Command line arguments","text":"<pre><code>Usage: gitql [OPTIONS]\n\nOptions:\n-r,  --repos &lt;REPOS&gt;        Path for local repositories to run query on\n-s,  --script &lt;file&gt;        Script file contains one or more query\"\n-q,  --query &lt;GQL Query&gt;    GitQL query to run on selected repositories\n-p,  --pagination           Enable print result with pagination\n-ps, --pagesize             Set pagination page size [default: 10]\n-o,  --output               Set output format [render, json, csv]\n-a,  --analysis             Print Query analysis\n-e,  --editor               Enable GitQL LineEditor\n-h,  --help                 Print GitQL help\n-v,  --version              Print GitQL Current Version\n</code></pre>"},{"location":"expression/","title":"Index","text":"<p>GitQL Expressions</p> <ul> <li>Binary expressions.</li> <li>Unary expressions.</li> <li>Case expression.</li> <li>Cast expression.</li> <li>Array expression.</li> <li>Access Member.</li> <li>Call expression.</li> <li>Interval expression.</li> </ul>"},{"location":"expression/access/","title":"Access Member","text":""},{"location":"expression/access/#member-access-expression","title":"Member Access Expression","text":"<p>GitQL support Composite Type inspired by PostgreSQL, to access member of composite type  you should use <code>.</code> operator like in any programming language but with putting the composite value in <code>()</code> like  <code>(user).username</code> to make it different from table column <code>table.column</code></p>"},{"location":"expression/array/","title":"Array","text":""},{"location":"expression/array/#array-value-expression","title":"Array value Expression","text":"<p>Array expression can be created using the <code>ARRAY</code> keyword followed by a list of expression between <code>[</code> and <code>]</code>.</p> <pre><code>SELECT ARRAY[1, 2, 3];\nSELECT ARRAY[ARRAY[1, 2, 3], ARRAY[4, 5, 6], ARRAY[7, 8, 9]];\n</code></pre> <p>Or you can write the list of expressions directly with <code>[</code> and <code>]</code></p> <pre><code>SELECT [1, 2, 3];\nSELECT [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n</code></pre>"},{"location":"expression/array/#slice-expression","title":"Slice Expression","text":"<p>Slice expression can be used to return a slice from array from <code>[start:end</code>.</p> <pre><code>SELECT [1, 2, 3][1:2];\nSELECT [[1, 2, 3], [4, 5, 6], [7, 8, 9]][1:2];\n</code></pre> <p>Slice expression can be used also with 1 as start range to return a slice from array from 1 to the end.</p> <pre><code>SELECT [1, 2, 3][:2];\nSELECT [[1, 2, 3], [4, 5, 6], [7, 8, 9]][:3];\n</code></pre> <p>Slice expression can be used also with start only range to return a slice from array from start to length of array.</p> <pre><code>SELECT [1, 2, 3][1:];\nSELECT [[1, 2, 3], [4, 5, 6], [7, 8, 9]][2:];\n</code></pre>"},{"location":"expression/binary/","title":"Binary","text":"<p>A binary expression contains two operands separated by one operator</p>"},{"location":"expression/binary/#arithmetic-expression","title":"Arithmetic Expression","text":"<p>Used to perform arithmetic operators on number types.</p> <ul> <li><code>+</code> Addition.</li> <li><code>-</code> Subtraction.</li> <li><code>*</code> Multiplication.</li> <li><code>/</code> Division.</li> <li><code>%</code> Modulus.</li> </ul>"},{"location":"expression/binary/#comparison-expression","title":"Comparison Expression","text":"<ul> <li><code>=</code> used to check if two values are equals.</li> <li><code>!=</code> or <code>&lt;&gt;</code> used to check if two values are not equals.</li> <li><code>&gt;</code> used to check value greater than other value.</li> <li><code>&gt;=</code> used to check if value is greater than or equals than other value</li> <li><code>&lt;</code> used to check if value is less than than other value.</li> <li><code>&lt;=</code> used to check if value is less than or equals than other value.</li> <li><code>&lt;=&gt;</code> Returns 1 rather than NULL if both operands are NULL, and 0 rather than NULL if one operand is NULL.</li> </ul>"},{"location":"expression/binary/#group-comparison-expression","title":"Group Comparison Expression","text":"<ul> <li><code>= [ALL | ANY | SOME]</code> used to check value equals againts a group of other values.</li> <li><code>!= [ALL | ANY | SOME]</code> or <code>&lt;&gt; [ALL | ANY | SOME]</code> used to check if two values are not equals.</li> <li><code>&gt; [ALL | ANY | SOME]</code> used to check value greater againts a group of other values.</li> <li><code>&gt;= [ALL | ANY | SOME]</code> used to check if value is greater than or equals againts a group of other values.</li> <li><code>&lt; [ALL | ANY | SOME]</code> used to check if value is less than againts a group of other values.</li> <li><code>&lt;= [ALL | ANY | SOME]</code> used to check if value is less than or equals than other a group of other values.</li> <li><code>&lt;=&gt; [ALL | ANY | SOME]</code> Returns 1 rather than NULL if both operands are NULL, and 0 rather than NULL if one operand is NULL.</li> </ul>"},{"location":"expression/binary/#contains-expression","title":"Contains Expression","text":"<ul> <li><code>@&gt;</code> Check if Range or Array contains other value.</li> </ul>"},{"location":"expression/binary/#contained-by-expression","title":"Contained by Expression","text":"<ul> <li><code>&lt;@</code> Check if Range or Array contained by other value.</li> </ul>"},{"location":"expression/binary/#like-expression","title":"Like Expression","text":"<p>The <code>LIKE</code> operator is used for searching for a specified pattern in a string.</p> <pre><code>SELECT \"Git Query Language\" LIKE \"G%\"\nSELECT \"Git Query Language\" LIKE \"%e\"\nSELECT \"Git Query Language\" LIKE \"%Query%\"\nSELECT \"10 usd\" LIKE \"[0-9]* usd\"\n</code></pre> <p>Between expression can also be used with <code>NOT</code> keyword for example</p> <pre><code>SELECT \"Git Query Language\" NOT LIKE \"G%\"\nSELECT \"Git Query Language\" NOT LIKE \"%e\"\nSELECT \"Git Query Language\" NOT LIKE \"%Query%\"\nSELECT \"10 usd\" NOT LIKE \"[0-9]* usd\"\n</code></pre>"},{"location":"expression/binary/#glob-expression","title":"Glob Expression","text":"<p>The <code>GLOB</code> operator is similar to <code>LIKE</code> but uses the Unix file globing syntax for its wildcards. Also, <code>GLOB</code> is case sensitive, unlike <code>LIKE</code>.</p> <pre><code>SELECT \"Git Query Language\" GLOB \"Git*\"\n</code></pre>"},{"location":"expression/binary/#logical-expressions","title":"Logical Expressions","text":"<ul> <li><code>||</code> or <code>or</code>: used to calculate logical or between two booleans,</li> <li><code>&amp;&amp;</code> or <code>and</code>: used to calculate logical and between two booleans,</li> <li><code>^</code> or <code>xor</code>: used to calculate logical xor between two booleans,</li> </ul>"},{"location":"expression/binary/#bitwise-expressions","title":"Bitwise Expressions","text":"<ul> <li><code>|</code>: used to calculate bitwise or between two numbers,</li> <li><code>&amp;</code>: used to calculate bitwise and between two numbers,</li> <li><code>&lt;&lt;</code>: used to calculate bitwise right shift between two numbers,</li> <li><code>&gt;&gt;</code>: used to calculate bitwise left shift between two numbers,</li> </ul>"},{"location":"expression/binary/#between-expression","title":"Between Expression","text":"<p>Used to check if value is between range start and end included</p> <pre><code>SELECT commit_count FROM branches WHERE commit_count BETWEEN 2 AND 30000\n</code></pre> <p>If you are not sure that the range start is greater than the range end, you can use the keyword <code>Symmetric</code></p> <pre><code>SELECT 1 BETWEEN 1 AND 3             -- True\nSELECT 1 BETWEEN 3 AND 1             -- False\nSELECT 1 BETWEEN SYMMETRIC 1 AND 3   -- True\n</code></pre> <p>Between expression can also be used with <code>NOT</code> keyword for example</p> <pre><code>SELECT 1 NOT BETWEEN 1 AND 3             -- False\nSELECT 1 NOT BETWEEN 3 AND 1             -- True\nSELECT 1 NOT BETWEEN SYMMETRIC 1 AND 3   -- False\n</code></pre>"},{"location":"expression/binary/#is-null-expression","title":"Is Null Expression","text":"<p>Returns true if value is null, can used with <code>NOT</code> keyword to return if true if not null</p> <pre><code>SELECT 1 IS NULL\nSELECT 1 IS NOT NULL\n</code></pre>"},{"location":"expression/binary/#in-expression","title":"In Expression","text":"<p>Returns true if any one or more values are equal to the argument</p> <pre><code>SELECT \"One\" IN (\"One\", \"Two\", \"Three\")\nSELECT \"One\" NOT IN (\"One\", \"Two\", \"Three\")\n</code></pre>"},{"location":"expression/binary/#regex-expression","title":"Regex Expression","text":"<p>Returns true if the string expr matches the regular expression specified by the pattern</p> <pre><code>SELECT \"a\" REGEXP \"^[a-d]\";\nSELECT \"a\" NOT REGEXP \"^[a-d]\";\n</code></pre>"},{"location":"expression/call/","title":"Call","text":""},{"location":"expression/call/#call-expression","title":"Call expression","text":""},{"location":"expression/call/#1-standard-function-calls","title":"1. Standard Function Calls","text":"<p>Standard functions call operate on individual rows and return a single value per row, with syntax similar to most programming languages for example</p> <pre><code>LEN(name)\nLOWER(author_name)\n</code></pre>"},{"location":"expression/call/#2-aggregate-function-calls","title":"2. Aggregate Function Calls","text":"<p>Aggregate functions call has the same syntax like standard function call but it's operate on a set of rows (a group) and return a single value for the entire group. They are often used with the <code>GROUP BY</code> clause, the value of aggregation function can be used only after group by statement.</p> <pre><code>SELECT author_name, COUNT(author_name) AS commit_num FROM commits GROUP BY author_name, author_email ORDER BY commit_num DESC LIMIT 10\n</code></pre>"},{"location":"expression/call/#3-window-functions","title":"3. Window functions","text":"<p>Window functions perform calculations across a set of rows that are related to the current row. Unlike aggregate functions with GROUP BY, window functions do not collapse rows into a single output row. Instead, they return a value for each input row based on a \"window\" of related rows, in window function call you must to explicit define <code>OVER</code> clauses even if it empty, also you can use aggregation function as window function.</p> <pre><code>SELECT emp_name, dep_name, ROW_NUMBER() OVER(PARTITION BY dep_name) AS row_number FROM emp_salaries\n\nSELECT emp_name,\n       dep_name,\n       ROW_NUMBER() OVER partition_dep_order_salary_des AS row_number_per_department,\n       MIN(salary) OVER partition_dep_order_salary_des AS min_salary_per_department,\n       MAX(salary) OVER partition_dep_order_salary_des AS max_salary_per_department\nFROM emp_salaries\nWINDOW partition_dep_order_salary_des AS (PARTITION BY dep_name ORDER BY salary DESC)\nORDER BY dep_name ASC NULLS LAST;\n</code></pre>"},{"location":"expression/case/","title":"Case","text":""},{"location":"expression/case/#case-expression","title":"Case expression","text":"<p>Case expression is similar to Switch Expression in many languages, it's return the value of the first branch that has condition evaluated to true, if not branch found it will return the default value</p> <pre><code>SELECT name FROM branches WHERE (CASE WHEN isRemote THEN 1 ELSE 0 END) &gt; 0\n</code></pre>"},{"location":"expression/cast/","title":"Cast","text":""},{"location":"expression/cast/#cast-expression","title":"Cast expression","text":"<p>In GitQL there are two types of casting, Explicit and Implicit casting</p>"},{"location":"expression/cast/#implicit-casting","title":"Implicit Casting","text":"<p>Implicit casting is performed without the need from you to write cast operator or function for example</p> <pre><code>SELECT True = 't'\n</code></pre> <p>In this case the engine perform implicit cast from Text 't' to become boolean 'true' so it's end up with</p> <pre><code>SELECT True = True\n</code></pre> <p>The same is performed when you write Date, Time or DateTime as String and pass it to function that accept Date.</p>"},{"location":"expression/cast/#explicit-casting","title":"Explicit Casting","text":"<p>Implicit casting can handle some cases when the value is const and has specific pattern, but in some cases you want for example to cast Float to Int or Int to Float after the value is evaluated or provided from real data, in this case you need to explicit ask the engine to case this value to another type, for example</p> <pre><code>SELECT CAST(commits_count AS Real);\n</code></pre> <p>Instead of using the above syntax, we can also use the following condensed syntax:</p> <pre><code>SELECT commits_count::Real;\n</code></pre>"},{"location":"expression/interval/","title":"Interval","text":""},{"location":"expression/interval/#interval-expression","title":"Interval expression","text":"<p>The Interval is another type of data type used to store and deploy Time in years, months, days, hours, minutes, seconds. And the years, months and days, hours and minutes values are integers values, whereas the second's field can be the fractions values.</p> <p>interval values can be written using the following verbose syntax:</p> <p>quantity: is a number (possibly signed)</p> <p>unit: is     microsecond, millisecond, second,     minute, hour, day, week, month, year,     decade, century, millennium, or abbreviations or plurals of these units</p> <p>direction: can be ago or empty</p> <p>The at sign (@) is optional noise</p> <p>Inspired by PostgreSQL, interval data type value involves 16 bytes storage size, which helps to store a period with the acceptable range from -178000000 years to 178000000 years.</p>"},{"location":"expression/interval/#examples","title":"Examples","text":"<pre><code>SELECT INTERVAL '1 y 1 d'\nSELECT INTERVAL '1 decade'\nSELECT INTERVAL '1 millennium ago'\nSELECT INTERVAL '1 years 1 days'  = INTERVAL '1 years 2 days';\nSELECT INTERVAL '1 years 1 days' != INTERVAL '1 years 2 days';\nSELECT INTERVAL '1 years 1 days'  + INTERVAL '1 years 2 days';\nSELECT INTERVAL '1 years 1 days'  - INTERVAL '1 years 2 days';\nSELECT INTERVAL '1 years 1 days' * 2;\nSELECT INTERVAL '2 years 2 days' / 2;\n</code></pre>"},{"location":"expression/unary/","title":"Unary","text":"<p>The unary expression is an expression the prefixed with operators</p>"},{"location":"expression/unary/#prefix-unary-expression","title":"Prefix Unary Expression","text":"<ul> <li><code>!</code> takes truth to falsity and vice versa. It is typically used with boolean</li> </ul> <pre><code>SELECT * FROM branches WHERE !is_remote\nSELECT * FROM branches WHERE !is_head\n</code></pre> <ul> <li><code>-</code> negates the value of the operand.</li> </ul> <pre><code>SELECT * FROM branches WHERE commit_count &gt; -1\n</code></pre>"},{"location":"functions/","title":"Index","text":"<p>GitQL Standard functions and operators</p> <ul> <li>Logical.</li> <li>comparison.</li> <li>Mathematical.</li> <li>Text.</li> <li>Date/Time.</li> <li>Regex.</li> <li>Array.</li> <li>Range.</li> <li>Interval.</li> <li>[Window] (window.md)</li> <li>Aggregations.</li> <li>General.</li> </ul>"},{"location":"functions/aggregations/","title":"Aggregate Functions","text":""},{"location":"functions/aggregations/#aggregations-functions","title":"Aggregations functions","text":"<p>An aggregate function in GitQL performs a calculation on multiple values and returns a single value</p> Name Parameters Return Description MAX ANY Any Return maximum value of it for all elements until the current one MIN ANY Any Return minimum value of it for all elements until the current one SUM Number Number Return the sum of items in a group. AVG Number Number Return the average of items in a group COUNT ANY? Any Return the number of items in a group GROUP_CONCAT ...Any Text Return string with concatenated non-NULL value from a group BOOL_AND Boolean Boolean Return true if all input values are true, otherwise false BOOL_OR Boolean Boolean Return true if at least one input value is true, otherwise false BIT_AND Integer Integer Return bitwise AND of all non-null input values, or null if none BIT_OR Integer Integer Return bitwise OR of all non-null input values, or null if none BIT_XOR Integer Integer Return bitwise XOR of all non-null input values, or null if none ARRAY_AGG Any Array(Any) Return an array of values"},{"location":"functions/array/","title":"Array","text":""},{"location":"functions/array/#array-operators","title":"Array operators","text":"Operator Arguments Description @&gt; (Array, T) Contains &lt;@ (T, Array) Contain by &amp;&amp; (Array, Array) Overlap"},{"location":"functions/array/#array-functions","title":"Array functions","text":"Name Parameters Return Description ARRAY_APPEND Array, Any Array Append element to the end of the array. ARRAY_PREPEND Any, Array Array Append element to the start of the array. ARRAY_REMOVE Array, Any Array Remove element from the array. ARRAY_CAT Array, Array Array Concatenates two arrays with the same type. ARRAY_LENGTH Array Integer Return the length of Array. ARRAY_SHUFFLE Array Array Return Randomly shuffles the first dimension of the array. ARRAY_POSITION Array, Any Integer Return the position of element in array or NULL if not found. ARRAY_POSITIONS Array, Any Array Return the an array of positions of element in array. ARRAY_DIMS Array Text Returns a text representation of the array's dimensions. ARRAY_REPLACE Array, Any, Any Array Replaces each array element equal to the second argument with the third argument. TRIM_ARRAY Array, Integer Array Remove the last n elements from the array. CARDINALITY Array Integer Counts the total number of array elements."},{"location":"functions/comparison/","title":"Comparison","text":""},{"location":"functions/comparison/#comparison-operators","title":"Comparison Operators","text":"Operator Description &lt; Less then &gt; Greater than &lt;= Less than or equal &gt;= Greater then or equal = Equal &lt;&gt; or != Not equal &lt;=&gt; Null Safe equal"},{"location":"functions/datetime/","title":"Date/Time","text":""},{"location":"functions/datetime/#date-time-and-datetime-operators","title":"Date, Time and DateTime operators","text":"Operator Arguments Description + (Date, Integer) Add a number of days to a date - (Date, Integer) Subtract a number of days to a date"},{"location":"functions/datetime/#date-time-and-datetime-functions","title":"Date, Time and DateTime functions","text":"Name Parameters Return Description Date DateTime Date Extracts the date part from a datetime expression. CURRENT_TIME Time Return current time in <code>HH:MM:SS</code> format. CURRENT_DATE Date Return current date in <code>YYYY-MM-DD</code> format. CURRENT_TIMESTAMP DateTime Return current date time in <code>YYYY-MM-DD HH:MM:SS</code> format. MAKEDATE Integer, Integer Date Create and return a date based on a year and a number of days. MAKETIME Integer, Integer, Integer Time Create and return a time value based on an hour, minute, and second value. NOW DateTime Return current date time in <code>YYYY-MM-DD HH:MM:SS</code> format. Day Date Integer Returns the index of the day (1 to 31) in the date. DAYNAME Date Text Returns the name of the day given a timestamp. MONTHNAME Date Text Returns the name of the month given a timestamp. HOUR DateTime Integer Returns the hour part of a datetime. MINUTE DateTime Integer Returns the minute part of a datetime. ISDATE Any Boolean Return TRUE if the argument type is Date. DAYOFWEEK Date Integer Returns the day of the week for a given date (a number from 1 to 7) DAYOFMONTH Date Integer Returns the day of the month for a given date (a number from 1 to 31) DAYOFYEAR Date Integer Returns the day of the year for a given date (a number from 1 to 366) WEEKOFYEAR Date Integer Returns the week number for a given date (a number from 1 to 53). QUARTER Date Integer Returns the quarter of the year for a given date value (a number from 1 to 4) YEAR Date Integer Returns the year part of the date MONTH Date Integer Returns the month part of the date (a number from 1 to 12) WEEKDAY Date Integer Returns the weekday number of the date (from 0 monday to 6 sunday) TO_DAYS Date Integer Returns the number of days between a date and date \"0000-00-00\" LAST_DAY Date Date Returns the last day of the month for a given date YEARWEEK Date Text Returns the year and week number (a number from 0 to 53) for a given date"},{"location":"functions/interval/","title":"Interval","text":""},{"location":"functions/interval/#interval-operators","title":"Interval Operators","text":"Operator Arguments Description + (Interval, Interval) addition two intervals - (Interval, Interval) subtraction two intervals * (Interval, Interval) multiplication two intervals / (Interval, Interval) division two intervals Name Parameters Return Description JUSTIFY_DAYS Interval Interval Adjust interval, converting 30-day time periods to months JUSTIFY_HOURS Interval Interval Adjust interval, converting 24-hour time periods to days"},{"location":"functions/logical/","title":"Logical","text":""},{"location":"functions/logical/#logical-operators","title":"Logical Operators","text":"Operator Description AND Logical AND &amp;&amp; Logical AND OR Logical OR || Logical OR XOR Logical XOR"},{"location":"functions/math/","title":"Mathematical","text":""},{"location":"functions/math/#mathematical-operators","title":"Mathematical Operators","text":"Operator Description + addition - subtraction * multiplication / division % modulo ^ exponentiation ~ bitwise NOT &amp; bitwise AND | bitwise OR # bitwise XOR &gt;&gt; bitwise shift left &lt;&lt; bitwise shift right"},{"location":"functions/math/#mathematical-functions","title":"Mathematical Functions","text":"Name Parameters Return Description PI Float Return the value of PI. FLOOR Float Integer Returns the largest integer value that is smaller than or equal to a number. ROUND Float, Integer? Float Returns a number rounded to a specified number of decimal places. SQUARE Integer Integer Returns the square of an integer value. ABS Number Number Returns the absolute value of an integer value. SIN Float Float Returns the sine of a number. ASIN Float Float Returns the arc sine of a number. COS FLOAT FLOAT Returns the cosine of a number. ACOS FLOAT FLOAT Returns the arc cosine of a number. TAN FLOAT FLOAT Returns the tangent of a number. ATAN FLOAT FLOAT Returns the arc tangent of a number. ATN2 FLOAT, FLOAT FLOAT Returns the arc tangent of two values. SIGN Number Integer Returns the sign of a number. MOD Integer, Integer Integer Returns the remainder of a number divided by another number. RAND Float? Float Returns a random number between 0 (inclusive) and 1 (exclusive)."},{"location":"functions/other/","title":"Other","text":""},{"location":"functions/other/#general-functions","title":"General functions","text":"Name Parameters Return Description ISNULL ANY Boolean Return TRUE if the argument type is null. ISNUMERIC ANY Boolean Return TRUE if the argument type is number. TYPEOF ANY Text Return the argument type name. GREATEST ANY, Any, ...Any Any Return the greatest value from list of values LEAST ANY, Any, ...Any Any Return the smallest value from list of values UUID Text Return a Universal Unique Identifier IF Boolean, T, T T Return second argument if the condition is TRUE otherwise return last argument IFNULL T, T T Return second argument if first one is null, otherwise return first one BENCHMARK Integer, Expression Int(0) Execute the expression n times and return 0"},{"location":"functions/range/","title":"Range","text":""},{"location":"functions/range/#range-operators","title":"Range operators","text":"Operator Arguments Description @&gt; (Range, T) Contains &lt;@ (T, Range) Contain by &amp;&amp; (Range, Range) Overlap"},{"location":"functions/range/#range-functions","title":"Range functions","text":"Name Parameters Return Description INT4RANGE Integer, Integer Range(Integer) Create a Range of integer type with start and end. DATERANGE Date, Date Range(Date) Create a Range of date type with start and end. TSRANGE DateTime, DateTime Range(DateTime) Create a Range of date time type with start and end. ISEMPTY Range Boolean Return true of this range is empty."},{"location":"functions/regex/","title":"Regex","text":""},{"location":"functions/regex/#regex-functions","title":"Regex functions","text":"Name Parameters Return Description REGEXP_INSTR Text, Text Integer Return starting index of substring matching regular expression. REGEXP_LIKE Text, Text Bool Returns true if the string expr matches the regular expression specified by the pattern. REGEXP_REPLACE Text, Text, Text Text Returns the input after replacing pattern with new content. REGEXP_SUBSTR Text, Text Text Returns substring matching regular expression ."},{"location":"functions/string/","title":"String","text":""},{"location":"functions/string/#string-functions","title":"String functions","text":"Name Parameters Return Description BIN Integer Text Return a string containing binary representation of a Integer. LOWER Text Text Return Text in lower case. UPPER Text Text Return Text in upper case. REVERSE Text Text Return a reversed string. TRIM Text Text Removes leading and trailing spaces from a string. LTRIM Text Text Removes leading spaces from a string. RTRIM Text Text Removes trailing spaces from a string. LEN Text Integer Return the length of this string. REPLICATE Text, Integer Text Return repeated a string a specified number of times. SPACE Integer Text Returns a string of the specified number of space characters. ASCII Text Integer Returns the ASCII value for the specific character. LEFT Text, Integer Text Extracts a number of characters from a string (starting from left). DATALENGTH Text Integer Returns the number of bytes used to represent an expression. CHAR Integer Text Returns the character based on the ASCII code. CHARINDEX Text, Text Integer Returns the starting position of the first occurrence of a string in another string. NCHAR Integer Text Returns the character based on the ASCII code. REPLACE Text, Text, Text Text Replaces all occurrences of a substring within a string, with a new substring. SUBSTRING Text, Integer, Integer Text Extracts some characters from a string. STUFF Text, Integer, Integer, Text Text Deletes a part of a string and then inserts another part into the string, starting at a specified position. RIGHT Text, Integer Text Extracts a number of characters from a string (starting from right). TRANSLATE Text, Text, Text, Text Returns the string from the first argument after the characters specified in the second argument are translated into the characters specified in the third argument. SOUNDEX Text Text Returns a four-character code to evaluate the similarity of two expressions. CONCAT Any, Any, ...Any Text Add several string representations of values together together. CONCAT_WS Text, Any, Any, ...Any Text Add several string representations of values together together with separate. UNICODE Text Integer Return an integer value (the Unicode value), for the first character of the input expression. STRCMP Text , Text Integer Return 0 If string1 = string2, -1 if string1 &lt; string2, this function returns -1, and 1 if string1 &gt; string2 QUOTENAME Text , Text Text Returns the string (first argument) with specified delimiters (second argument), defaulting to [] STR Text, Integer?, Integer? Text Returns a number as a string with optionals length and decimals. TO_HEX Integer Text Returns a number as a string with hex decimal format."},{"location":"functions/window/","title":"Window Functions","text":""},{"location":"functions/window/#aggregations-functions","title":"Aggregations functions","text":"<p>A Window function in GitQL performs a calculation on a window (frame) of values and returns a single value</p> Name Parameters Return Description FIRST_VALUE ANY Any Return first value in the window of values NTH_VALUE ANY, INT Any Return n value in the window of values LAST_VALUE ANY Any Return last value in the window of values ROW_NUMBER INT Return unique sequential integer to each row within the partition, starting from 1"},{"location":"sdk/","title":"Index","text":"<p>The GitQL Query engine is designed to work as a set of decoupled libraries which gives you the flexibility to extend or replace any part of the query execution journey.</p>"},{"location":"sdk/#gitql-engine-architecture","title":"GitQL Engine Architecture","text":"<pre><code>graph LR\n  A[SQL Query] --&gt; B[Tokenizer];\n  B --&gt; C[Parser and Type Checker];\n  C --&gt; D[Execution Engine];\n  D --&gt; E[Output]\n  F[Schema] --&gt; C;\n  G[Data Provider] --&gt; D;\n  H[Standard library] --&gt; D;</code></pre>"},{"location":"sdk/#gitql-sdk-components","title":"GitQL SDK Components","text":"Component Description Install gitql-core Core components <code>cargo install gitql-core</code> gitql-std Standard library functions <code>cargo install gitql-std</code> gitql-cli CLI components like args parser, cli reporter <code>cargo install gitql-cli</code> gitql-ast structures components such as AST, Types <code>cargo install gitql-ast</code> gitql-parser Parser and Type checker components <code>cargo install gitql-parser</code> gitql-engine Execution engine component <code>cargo install gitql-engine</code>"},{"location":"sdk/#using-the-gitql-sdk-to-extend-the-components","title":"Using the GitQL SDk to extend the components","text":"<p>As you will see building your own query language for specific need using the GitQL gives you the ability to customize every part of the engine such as operators, types, schema, functions ...etc.</p> <ul> <li>Customize the Data Schema.</li> <li>Customize the Data Provider.</li> <li>Customize the Standard library.</li> <li>Customize the Type system.</li> <li>Customize the Value system.</li> </ul>"},{"location":"sdk/#example-of-product-that-build-on-top-of-gitql","title":"Example of product that build on top of GitQL","text":"<ul> <li> <p>ClangQL: To run SQL query on C/C++ Code.</p> </li> <li> <p>FileQL: To run SQL query on the file system.</p> </li> <li> <p>LLQL:   Tool to run SQL query on LLVM IR/BC and perform Pattern matching on instructions.</p> </li> <li> <p>PyQL: To run SQL query on Python Code.</p> </li> </ul> <p>Feel free to add your product too, everyone is welcome to join.</p>"},{"location":"sdk/assemble/","title":"Start the SDK","text":"<p>Now after we creating our <code>Schema</code>, <code>DataProvider</code>, may or may not add custom functions, types and values, it's time to make SDK components work together</p> <pre><code>// Create instance of your Schema\nlet schema = Schema {\n    tables_fields_names: tables_fields_names().clone(),\n    tables_fields_types: tables_fields_types().clone(),\n};\n\n// Pass  the standard functions, or your custom functions or mix of them to the env\nlet std_signatures = standard_functions();\nlet std_functions = standard_function_signatures();\n\nlet aggregation_signatures = aggregation_function_signatures();\nlet aggregation_functions = aggregation_functions();\n\nlet mut env = Environment::new(schema);\nenv.with_standard_functions(&amp;std_signatures, std_functions);\nenv.with_aggregation_functions(&amp;aggregation_signatures, aggregation_functions);\n\n// Create instance of the diagnostic reporter, to report errors, warns ...etc\nlet mut reporter = DiagnosticReporter::default();\n\n// Pass the query to the tokenizer to get List of tokens or error\nlet tokensOrError = tokenizer::tokenize(query.clone());\n\n// If tokenizer return error, report it and stop\nif tokensOrError.is_err() {\n    let diagnostic = tokensOrError.err().unwrap();\n    reporter.report_diagnostic(&amp;query, *diagnostic);\n    return;\n}\n\n// Get the list of tokens\nlet tokens = tokensOrError.ok().unwrap();\n\n// Start the parser to get AST or error\nlet astOrError = parser::parse_gql(tokens, env);\n\n// Same like tokenizer if it return error, report it and stop\nif astOrError.is_err() {\n    let diagnostic = astOrError.err().unwrap();\n    reporter.report_diagnostic(&amp;query, *diagnostic);\n    return;\n}\n\nlet query_ast = astOrError.ok().unwrap();\n\n// Create instance of your data provider\nlet provider: Box&lt;dyn DataProvider&gt; = Box::new(FileDataProvider::new(repos.to_vec()));\n\n// Pass the ast and provider to the execution engine to get result or error\nlet evaluation_result = engine::evaluate(env, &amp;provider, query_node);\n\n// Report Runtime exceptions if they exists\nif evaluation_result.is_err() {\n    reporter.report_diagnostic(\n        &amp;query,\n        Diagnostic::exception(&amp;evaluation_result.err().unwrap()),\n    );\n    return;\n}\n\nlet execution_result = evaluation_result.ok().unwrap();\n\n// When you get result with selected groups, you can print them like table, json, csv or your custom format\nif let SelectedGroups(mut groups) = engine_result {\n    let pagination = true;\n    let page_size = 10;\n    let printer = Box::new(TablePrinter::new(pagination, page_size));\n    printer.print(&amp;mut groups);\n}\n</code></pre> <p>Thats it, now you can create a customizable query language with your own schema, data, types and functions.</p> <p>Enjoy.</p>"},{"location":"sdk/functions/","title":"Functions","text":"<p>By default the <code>gitql-std</code> component contains the standard functions and aggregations functions inspired by SQLite, MySQL, PostgreSQL, MSSQL ...etc.</p> <p>This can be more than enough in most cases, but maybe you want to create a special functions related to your data, or your custom type.</p>"},{"location":"sdk/functions/#creating-a-custom-function","title":"Creating a custom function","text":"<p>To create a new function you need to provide a name, signature (What are parameters types and return type) and the actual function implementation, the SDK expects a Map with type <code>HashMap&lt;&amp;'static str, Signature&gt;</code> to map function name to the signature, and another map of type <code>&amp;'static HashMap&lt;&amp;'static str, Function&gt;</code> to map function name to the actual implementation.</p> <p>By default you can got those two maps with all standard functions like this</p> <pre><code>let std_functions = standard_functions().to_owned();\nlet std_signatures = standard_function_signatures().to_owned();\n</code></pre> <p>You can remove, replace or insert in those maps, lets take an example of adding new function</p> <p>Lets start by the function implementation, it should take an Array of Values as arguments, and return Value, so our function will take two parameters, file path and extension, and return true if this path end with this extension</p> <pre><code>fn is_file_has_extension(values: &amp;[Box&lt;dyn Value&gt;]) -&gt; Box&lt;dyn Value&gt; {\n    // Get the first argument\n    let file_path = values[0].as_text().unwrap();\n    // Get the other argument\n    let extension = values[1].as_text().unwrap();\n    // Check if path end with this extension\n    let is_true   = file_path.ends_with(&amp;extension);\n    // Return result\n    Box::new(BoolValue { value : is_true })\n}\n</code></pre> <p>After implementing our new function let append it to our clone of the standard functions</p> <pre><code>// Append the function implementation\nlet mut std_functions = standard_functions().to_owned();\nstd_functions.insert(\"is_file_has_extension\", is_file_has_extension);\n\n// Append the function signature\nlet mut std_signatures = standard_function_signatures().to_owned();\nstd_signatures.insert(\n    \"is_file_has_extension\",\n    Signature {\n        // Take two Text values\n        parameters: vec![Box::new(TextType), Box::new(TextType)],\n        // Return Bool value\n        return_type: Box::new(BoolType),\n    }\n);\n</code></pre> <p>NOTE:  You can remove functions, or even create a new empty map with only your functions.</p> <p>NOTE:  The same concepts works with Aggregations functions.</p> <p>NOTE:  Later you will see how to create function with your own types.</p>"},{"location":"sdk/provider/","title":"Data Provider","text":"<p>After defining the Schema of your custom data to the SDK you need to teach the Engine from where and how it can load the data? this can be different from project to another one, so this part is created as an interface called <code>DataProvider</code>, which you can implement it for any kind of data, files, git, code AST, API response, system information ...etc, Sky is the limit.</p>"},{"location":"sdk/provider/#data-provider-interface","title":"Data Provider Interface","text":"<p>The Data Provider is a single function interface that take the target table name and which columns the query need, and then you either return the list of Rows or an String with error message.</p> <pre><code>pub trait DataProvider {\n    fn provide(&amp;self, \n        table: &amp;str, \n        selected_columns: &amp;[String]\n    ) -&gt; Result&lt;Vec&lt;Row&gt;, String&gt;;\n}\n</code></pre> <p>NOTE:  You don't need to check here if this column is valid or not, this done in the parser depending on your schema.</p> <p>NOTE:  You can cache and restore the data from and to this provider.</p> <p>NOTE:  You can traverse and build the list of rows in single or multi thread.</p> <p>So lets try to implement a simple Data provider for file system, first lets create a custom data provider that contains what paths we should search in and what files we should excludes.</p> <pre><code>use gitql_engine::data_provider::DataProvider;\n\npub struct FileDataProvider {\n    pub paths: Vec&lt;String&gt;,\n    pub excludes: Vec&lt;String&gt;,\n}\n\nimpl FileDataProvider {\n    pub fn new(paths: Vec&lt;String&gt;, excludes: Vec&lt;String&gt;) -&gt; Self {\n        Self { paths, excludes }\n    }\n}\n</code></pre> <p>Now lets implement the <code>provide</code> function to provide data from file system, i recommend to create a function for each table, to keep every thing organize</p> <pre><code>impl DataProvider for FileDataProvider {\n    fn provide(&amp;self, table: &amp;str, selected_columns: &amp;[String]) -&gt; Result&lt;Vec&lt;Row&gt;, String&gt; {\n        match table {\n            \"files\" =&gt; select_files(&amp;self.paths, &amp;self.excludes, selected_columns),\n            _ =&gt; Ok(vec![Row { values: vec![] }]),\n        }\n    }\n}\n\nfn select_files(\n    paths: &amp;[String],\n    excludes: &amp;[String],\n    selected_columns: &amp;[String],\n) -&gt; Result&lt;Vec&lt;Row&gt;, String&gt; {\n    let files = collect_paths_nested_files_and_excludes(paths, excludes);\n\n    let mut rows: Vec&lt;Row&gt; = Vec::with_capacity(paths.len());\n\n    // Iterate over each file to extract information that we need\n    for file in files.iter() {\n        // Preallocate the list of values in this row\n        let mut values: Vec&lt;Value&gt; = Vec::with_capacity(selected_columns.len());\n        let path = Path::new(&amp;file);\n\n        for column_name in selected_columns {\n            if column_name == \"file_name\" {\n                let file_path_string = path.to_str().unwrap_or(\"\");\n                values.push(Box::new(TextValue {\n                    value: file_path_string.to_string(),\n                }));\n                continue;\n            }\n\n            if column_name == \"is_dir\" {\n                values.push(Box::new(BoolValue {\n                    value: path.is_dir(),\n                }));\n                continue;\n            }\n\n            // If this symbol is not a column name\n            values.push(Box::new(NullValue));\n        }\n\n        // Create a new fow for this file and append it to the result rows\n        let row = Row { values };\n        rows.push(row);\n    }\n\n    // Return the rows if every thing is Okay, or return error\n    Ok(rows)\n}\n</code></pre> <p>To create DataProvider instance</p> <pre><code>let provider: Box&lt;dyn DataProvider&gt; = \n    Box::new(FileDataProvider::new(paths, excludes));\n</code></pre> <p>And now our Data Provider is done and ready to use, this code is not dummy, it's actual code from <code>FileQL</code> Data Provider.</p>"},{"location":"sdk/schema/","title":"Schema","text":"<p>The GitQL parser and engine should be aware of what kind of data it should deal with, so it can provide a clean error messages, and apply the right operators, this information defined in a structure way in place called the <code>Schema</code>, and this schema contains</p> <ul> <li>What tables you have.</li> <li>What are the columns in each tables and what are their types.</li> </ul> <pre><code>pub struct Schema {\n    pub tables_fields_names: HashMap&lt;&amp;'static str, Vec&lt;&amp;'static str&gt;&gt;,\n    pub tables_fields_types: HashMap&lt;&amp;'static str, Box&lt;dyn DataType&gt;&gt;,\n}\n</code></pre> <p>So for your custom purpose you need to define your own schema, let take an example of a simple file system, so you have a table called <code>files</code>, and this table has two columns, <code>file_name</code> as Text (aka String), and <code>is_directory</code> as Boolean.</p>"},{"location":"sdk/schema/#define-the-columns-types","title":"Define the columns types","text":"<pre><code>pub fn tables_fields_types() -&gt; HashMap&lt;&amp;'static str, Box&lt;dyn DataType&gt;&gt; {\n    let mut map: HashMap&lt;&amp;'static str, Box&lt;dyn DataType&gt;&gt; = HashMap::new();\n    map.insert(\"file_name\", Box::new(TextType));\n    map.insert(\"is_directory\", Box::new(BoolType));\n    map\n}\n</code></pre>"},{"location":"sdk/schema/#define-the-table-name-and-his-columns","title":"Define the table name and his columns","text":"<pre><code>pub fn tables_fields_names() -&gt; &amp;'static HashMap&lt;&amp;'static str, Vec&lt;&amp;'static str&gt;&gt; {\n    static HASHMAP: OnceLock&lt;HashMap&lt;&amp;'static str, Vec&lt;&amp;'static str&gt;&gt;&gt; = OnceLock::new();\n    HASHMAP.get_or_init(|| {\n        let mut map = HashMap::new();\n        map.insert(\"files\", vec![\"file_name\", \"is_directory\"]);\n        map\n    );\n}\n</code></pre>"},{"location":"sdk/schema/#create-a-schema-object-with-those-information","title":"Create a schema object with those information","text":"<pre><code>let schema = Schema {\n    tables_fields_names: tables_fields_names().to_owned(),\n    tables_fields_types: tables_fields_types().to_owned(),\n};\n</code></pre> <p>Later this schema instance with the standard library will used to create the environment</p> <pre><code>let mut env = Environment::new(schema);\n</code></pre>"},{"location":"sdk/types/","title":"Types","text":"<p>Now after creating our own <code>Schema</code>, <code>DataProvider</code> and <code>Standard function</code>, most of the cases can be handled  at this level, but what if you want to store the values in other type than <code>Int</code>, <code>Float</code>, <code>Text</code> ...etc,  for example you want to create a type called <code>Song</code> or <code>Video</code> and then you can run a query asking  what is the longest video in each directory? or what if you want to create a function that take a TreeNode and return number children nodes?</p> <p>To allow this level of customization in type system we need to make it easy to integrate with the parser, type checker  and execution engine? we can't support every possible type in the engine.</p> <p>But .... What if we support 0 types \ud83e\udd14 .... what if the types are not primitives in the engine but defined in the Standard library or the SDK?</p>"},{"location":"sdk/types/#moving-the-types-from-the-engine-to-the-sdk-level","title":"Moving the Types from the Engine to the SDK level","text":"<p>This idea is inspired by <code>Chris Lattner</code> design in Mojo and Swift programming languages,  by default the Engine has some built in predefined types like <code>Integer</code>, <code>Float</code>, <code>Boolean</code> ...etc, it know very well  what operators can work with them, how can cast them, this can work well and programming languages gives you the ability to  compose types and create Structured data types like <code>List</code>, <code>File</code>, <code>GamePlayer</code> ...etc, but what if we create a way to define your own type,  and define how the Engine or the Compiler can deal with it, define what operators work with it, in this case we can define <code>Integer</code>, <code>Float</code> as part of the Standard library or in our case the SDK, and that also gives the SDK user the power to built any type he want to make it integrated well in all part of the Query Engine.</p> <p>Lets for example say we want to create type called <code>IntPair</code> and define attributes and operators for it,</p>"},{"location":"sdk/types/#creating-a-custom-datatype","title":"Creating a custom DataType","text":"<pre><code>use std::any::Any;\n\nuse super::base::DataType;\n\n#[derive(Clone)]\npub struct IntPairType;\n\nimpl DataType for IntPairType {\n\n    /// Define the literal representation for our new type\n    fn literal(&amp;self) -&gt; String {\n        \"IntPair\".to_string()\n    }\n\n    /// Define how to compare this type with others\n    fn equals(&amp;self, other: &amp;Box&lt;dyn DataType&gt;) -&gt; bool {\n        let int_pair_type: Box&lt;dyn DataType&gt; = Box::new(self.clone());\n        other.is_any() || other.is_int() || other.is_variant_contains(&amp;int_pair_type)\n    }\n\n    fn as_any(&amp;self) -&gt; &amp;dyn Any {\n        self\n    }\n\n    /// Allow using the `+` operator between two IntPair's\n    fn can_perform_add_op_with(&amp;self) -&gt; Vec&lt;Box&lt;dyn DataType&gt;&gt; {\n        vec![Box::new(IntPairType)]\n    }\n\n    /// Define that the result of IntPair + IntPair will be another IntPair\n    fn add_op_result_type(&amp;self, _other: &amp;Box&lt;dyn DataType&gt;) -&gt; Box&lt;dyn DataType&gt; {\n        Box::new(IntPairType)\n    }\n\n    /// Define any other operators like -, *, %, &gt;, ...etc\n}\n</code></pre> <p>Now if we create a new Function with Signature that accept IntPair and we pass Int, it will report an error, but now we created a Type but to create a Value with this type we need to create a Custom Value too (Creating the IntPairValue as Custom value).</p>"},{"location":"sdk/types/#register-your-type-in-typestable","title":"Register your type in TypesTable","text":"<p>If you want to support using your type in explicit casting feature, for example</p> <pre><code>SELECT CAST(value AS IntPairType)\n</code></pre> <p>You must register your type to the TypesTable component and pass it to the <code>Environment</code> for example</p> <pre><code>let types_table = TypesTable::new();\ntypes_table.register(\"intpair\", Box::new(IntPairType));\n\nlet env = Environment::new();\nenv.register_types_table(types_table);\n</code></pre>"},{"location":"sdk/values/","title":"Values","text":"<p>Now we created a new Type called <code>IntPairType</code> that can be used as Function parameter, return type or column type, but we need a custom value that can represent this type, it's almost the same concept, so lets start creating the <code>IntPairValue</code>.</p> <pre><code>use gitql_ast::types::DataType;\n\nuse super::base::Value;\n\n#[derive(Clone)]\npub struct IntPairValue {\n    pub first: i64,\n    pub second: i64,\n}\n\nimpl Value for IntPairValue {\n\n    /// Define the literal representation for our new Value\n    fn literal(&amp;self) -&gt; String {\n        format!(\"({}, {})\", self.first, self.second)\n    }\n\n    /// Define how to check equality between this value and other\n    fn equals(&amp;self, other: &amp;Box&lt;dyn Value&gt;) -&gt; bool {\n        if let Some(other_int_pair) = other.as_any().downcast_ref::&lt;IntPairValue&gt;() {\n            return self.first == other_int_pair.first \n                &amp;&amp; self.second == other_int_pair.second;\n        }\n        false\n    }\n\n    /// You can define how to order between IntPair values or None to disable ordering\n    fn compare(&amp;self, other: &amp;Box&lt;dyn Value&gt;) -&gt; Option&lt;Ordering&gt; {\n        None\n    }\n\n    fn data_type(&amp;self) -&gt; Box&lt;dyn DataType&gt; {\n        Box::new(IntPairType)\n    }\n\n    fn as_any(&amp;self) -&gt; &amp;dyn Any {\n        self\n    }\n\n    /// As we allowed `+` between IntPair types in `can_perform_add_op_with` \n    /// We need also to define how this operator will work\n    fn add_op(&amp;self, other: &amp;Box&lt;dyn Value&gt;) -&gt; Result&lt;Box&lt;dyn Value&gt;, String&gt; {\n        if let Some(other_int) = other.as_any().downcast_ref::&lt;IntPairValue&gt;() {\n            let first = self.first + other_int.first;\n            let second = self.second + other_int.second;\n            return Ok(Box::new(IntPairValue { first, second }));\n        }\n\n        /// Write your exception message\n        Err(\"Unexpected type to perform `+` with\".to_string())\n    }\n}\n</code></pre>"},{"location":"sdk/values/#creating-function-to-construct-intpairvalue","title":"Creating Function to construct IntPairValue","text":"<pre><code>fn new_int_pair(values: &amp;[Box&lt;dyn Value&gt;]) -&gt; Box&lt;dyn Value&gt; {\n    let first = values[0].as_int().unwrap();\n    let second = values[1].as_int().unwrap();\n    Ok(Box::new(IntPairValue { first, second }))\n}\n</code></pre>"},{"location":"sdk/values/#register-this-function-signature-and-implementation","title":"Register this function signature and implementation","text":"<pre><code>// Append the function implementation\nlet mut std_functions = standard_functions().to_owned();\nstd_functions.insert(\"new_int_pair\", new_int_pair);\n\n// Append the function signature\nlet mut std_signatures = standard_function_signatures().to_owned();\nstd_signatures.insert(\n    \"new_int_pair\",\n    Signature {\n        // Take two Integers values\n        parameters: vec![Box::new(IntType), Box::new(IntType)],\n        // Return IntPair Value\n        return_type: Box::new(IntPairValue),\n    }\n);\n</code></pre> <p>After connecting everything together in the next step, you can perform query like this</p> <pre><code>SELECT new_int_pair(1, 2) + new_int_pair(3, 4);\n</code></pre> <p>And got result like <code>(4, 6)</code>.</p>"},{"location":"sdk/values/#going-forward","title":"Going forward","text":"<p>This is just a quick example of how to create your own types, but you can create any type you want, even Data structures like Map and allow index operator for it so you can write </p> <pre><code>SELECT map[\"key\"]\n</code></pre>"},{"location":"statement/","title":"Index","text":"<p>GitQL Statements</p> <ul> <li>Variables Statement.</li> <li>Select Statement.</li> <li>Do Statement.</li> <li>Where Statement.</li> <li>Having Statement.</li> <li>Order by Statement.</li> <li>Group by Statement.</li> <li>Limit and Offset Statements.</li> </ul>"},{"location":"statement/do/","title":"Do","text":"<p>The <code>Do</code> works in a similar way to the SELECT statement, but without returning a result set</p> <p>For example to select all fields from commits table.</p> <pre><code>DO SLEEP(10);\n</code></pre> <p>Where DO Cannot be Used</p> <p>We can\u2019t use DO everywhere that we can use SELECT. For example we can\u2019t do the following:</p> <pre><code>DO * FROM branches;\n</code></pre>"},{"location":"statement/group_by/","title":"Group by","text":""},{"location":"statement/group_by/#group-by-statement","title":"Group By Statement","text":"<p>The <code>GROUP BY</code> statement groups rows that have the same values into summary rows, like \"find the number of commits for each username or email\".</p> <pre><code>SELECT * FROM commits GROUP BY author_name\nSELECT * FROM commits GROUP BY author_name, author_email\nSELECT * FROM commits GROUP BY LEN(author_name)\n</code></pre> <p>You can use The ROLLUP feature to extends GROUP BY to include subtotals and grand totals in the result set.</p> <pre><code>SELECT COUNT() FROM commits GROUP BY author_name WITH ROLLUP\n</code></pre>"},{"location":"statement/having/","title":"Having","text":"<p>The <code>HAVING</code> statement is very similar to <code>WHERE</code> expect that it evaluated after the <code>GROUP BY</code> statement</p> <pre><code>SELECT * FROM commits GROUP BY author_name HAVING author_name = \"AmrDeveloper\"\nSELECT * FROM branches GROUP BY name HAVING is_head = \"true\"\n</code></pre>"},{"location":"statement/limit_and_offset/","title":"Limit & Offset","text":"<p>The <code>LIMIT</code> statement used to limit the number of end result</p> <pre><code>SELECT * FROM commits LIMIT 10\nSELECT * FROM branches LIMIT 15\n</code></pre> <p>The <code>OFFSET</code> statement specifies how many rows to skip at the beginning of the result set</p> <pre><code>SELECT * FROM commits OFFSET 10\nSELECT * FROM branches OFFSET 15\n</code></pre> <p>You can mix the offset and limit statements</p> <pre><code>SELECT * FROM commits OFFSET 10 LIMIT 10\nSELECT * FROM branches OFFSET 15 LIMIT 15\n</code></pre>"},{"location":"statement/order_by/","title":"Order by","text":"<p>The <code>ORDER BY</code> Statement used to order the result-set in ascending or descending order by one or more arguments.</p> <pre><code>SELECT author_name, author_email FROM commits ORDER BY author_name\nSELECT author_name, author_email FROM commits ORDER BY author_name, author_email\nSELECT author_name, author_email FROM commits ORDER BY author_email, commit_id ASC\nSELECT author_name, author_email FROM commits ORDER BY author_name DESC\nSELECT author_name, author_email FROM commits ORDER BY author_name, LEN(author_name)\n</code></pre> <p>The <code>ORDER BY</code> Statement with <code>USING &lt;operator&gt;</code> syntax inspired by PostgreSQL</p> <pre><code>SELECT author_name, author_email FROM commits ORDER BY author_email, commit_id USING &lt;\nSELECT author_name, author_email FROM commits ORDER BY author_name USING &gt;\n</code></pre> <p>You can define nulls order policy to set if you want null value to be first or last in the order</p> <pre><code>SELECT author_name, author_email FROM commits ORDER BY author_email NULLS FIRST\nSELECT author_name, author_email FROM commits ORDER BY author_name NULLS LAST\n</code></pre>"},{"location":"statement/qualify/","title":"Qualify","text":"<p>The <code>QUALIFY</code> statement is very similar to <code>WHERE</code> expect that it evaluated after the <code>WINDOW functions</code></p>"},{"location":"statement/select/","title":"Select","text":""},{"location":"statement/select/#select-statement","title":"Select Statement","text":"<p>The <code>SELECT</code> statement is used to query data from a single table</p> <p>For example to select all fields from commits table.</p> <pre><code>SELECT * FROM commits\n</code></pre> <p>Or Selecting just title and message</p> <pre><code>SELECT title message FROM commits\n</code></pre> <p>You can use Aggregation function in the select statement to perform function on all data until the current one</p> <pre><code>SELECT count(author_name) FROM commits\n</code></pre> <p>You can alias the column name only in this query by using <code>AS</code> keyword for example</p> <pre><code>SELECT title as commit_title FROM commits\nSELECT title as \"Commit Title\" FROM commits\nSELECT name, commit_count, max(commit_count) AS max_count message FROM branches\n</code></pre>"},{"location":"statement/select/#distinct-option","title":"Distinct option","text":"<p>You can select unique rows only using the <code>distinct</code> keyword for example,</p> <pre><code>SELECT DISTINCT title AS tt FROM commits\n</code></pre>"},{"location":"statement/select/#distinct-on-option","title":"Distinct On option","text":"<p>You can select rows with unique fields using the <code>distinct on</code> keyword with one or more field for example,</p> <pre><code>SELECT DISTINCT ON (author_name) title AS tt FROM commits\n</code></pre>"},{"location":"statement/select/#joins","title":"Joins","text":"<p>You can perform one or more JOIN to join two tables together, you can use one of four different join types, which are Inner, Cross, Left and Right outer JOINS and also filter by on predicate condition.</p> <pre><code>SELECT COUNT() FROM tags JOIN branches\nSELECT COUNT() FROM tags LEFT JOIN branches ON commit_count &gt; 1\nSELECT COUNT() FROM tags RIGHT JOIN branches ON commit_count &gt; 1\n</code></pre>"},{"location":"statement/select/#select-into","title":"Select ... INTO","text":"<p>You can export the query result into external file using the syntax <code>INTO OUTFILE &lt;File&gt; &lt;options&gt;</code></p> <pre><code>SELECT name FROM branches INTO OUTFILE \"branches.txt\"\n</code></pre> <p>You can format the output result with options for example</p> <pre><code>SELECT * FROM branches INTO OUTFILE \"branches.txt\" FIELDS TERMINATED BY \",\" LINES TERMINATED BY \"\\n\" ENCLOSED \"|\"\n</code></pre> <p>If you want to just dump the data without any format you can use <code>INTO DUMPFILE</code></p> <pre><code>SELECT * FROM branches INTO DUMPFILE \"braches.txt\"\n</code></pre>"},{"location":"statement/variables/","title":"Variables","text":"<p>GitQL has support for global variables with syntax inspired by MySQL</p>"},{"location":"statement/variables/#declare-variable-with-value","title":"Declare variable with value","text":"<pre><code>SET @one = 1\nSET @STRING = \"GitQL\"\n</code></pre>"},{"location":"statement/variables/#use-the-variable","title":"Use the variable","text":"<p>You can use the variable like any other symbol using the name</p> <pre><code>SELECT @one\n</code></pre>"},{"location":"statement/where/","title":"Where","text":"<p>The <code>WHERE</code> statement is used to filter the data by one or more conditions</p> <p>For example to select all commits for a specific username</p> <pre><code>SELECT * FROM commits where author_name = \"AmrDeveloper\"\nSELECT * FROM branches WHERE is_head = \"true\"\n</code></pre> <p>You can add Unary and Binary expressions, but you can use Aggregation functions inside the Where statement, because it calculated after the group by statement.</p>"},{"location":"structure/tables/","title":"Tables","text":""},{"location":"structure/tables/#gql-tables","title":"GQL Tables","text":"<p>You can see list of all tables directly in the repl using</p> <pre><code>show tables\n</code></pre>"},{"location":"structure/tables/#references-table","title":"References table","text":"Name Type Description name Text Reference name full_name Text Reference full name type Text Reference type repo Text Repository full path"},{"location":"structure/tables/#commits-table","title":"Commits table","text":"Name Type Description commit_id Text Commit id title Text Commit title message Text Commit full message author_name Text Author name author_email Text Author email committer_name Text Committer name committer_email Text Committer email parents_count Integer Number of commit parents datetime DateTime Commit date time repo Text Repository full path"},{"location":"structure/tables/#diffs-table","title":"Diffs table","text":"Name Type Description commit_id Text Commit id author_name Text Author name author_email Text Author email insertions Integer Number of inserted lines removals Integer Number of deleted lines files_changed Integer Number of file changed diff_changes DiffChanges Diff content and info for changes datetime DateTime Commit date time repo Text Repository full path"},{"location":"structure/tables/#diffs-changes-table","title":"Diffs Changes table","text":"Name Type Description commit_id Text Commit id insertions Integer Number of inserted lines in one change removals Integer Number of deleted lines in one change mode Text Change mode A for Add, D for Delete, M for Modification, C for Copy or R for Rewrite path Text Location of the change repo Text Repository full path"},{"location":"structure/tables/#branches-table","title":"Branches table","text":"Name Type Description name Text Branch name commit_count Number Number of commits in this branch is_head Bool Is the head branch is_remote Bool Is a remote branch updated DateTime Last update Commit date time repo Text Repository full path"},{"location":"structure/tables/#tags-table","title":"Tags table","text":"Name Type Description name Text Tag name repo Text Repository full path"},{"location":"structure/tables/#list-all-tables-in-the-current-schema","title":"List all tables in the current schema","text":"<pre><code>SHOW TABLES;\n</code></pre>"},{"location":"structure/tables/#query-the-description-of-table-by-name","title":"Query the description of table by name","text":"<pre><code>DESCRIBE commits;\nDESCRIBE branches;\n</code></pre>"},{"location":"structure/types/","title":"Types","text":"<p>The GQL has a basic type system with only four types to be used for safe functions call and expressions.</p>"},{"location":"structure/types/#types-informations","title":"Types information's","text":"Name Description Any Used to represent Any data type Text Used to represent string literal Integer Used to represent integers Float Used to represent floats Boolean Used to represent boolean value Date Used to represent date Time Used to represent time DateTime Used to represent date &amp; time Array(type) Used to represent an array of type Range(type) Used to represent a range of type Variant(types) Used to represent a variant of types Optional(type) Used to represent a optional type or none Varargs(type) Used to represent a variable arguments type Composite Used to represent a composite of other types"}]}